#!/usr/bin/env ruby

require 'logger'
require 'ruby-prof'
require 'net/http'
require 'securerandom'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), "..", "lib")

Signal.trap("SIGPIPE", "SYSTEM_DEFAULT")
require 'pin2dmd_dump'

filename = ARGV.shift

$logger = Logger.new(STDOUT)
$logger.formatter = proc do |severity, datetime, progname, msg|
  date_format = datetime.strftime("%Y-%m-%d %H:%M:%S.%L")
  "#{severity} [#{date_format}]: #{msg}\n"
end
$logger.info("Loading #{filename}")
dump = Pin2DmdDump.from_file(filename)
$logger.info("Loaded #{filename}")

$logger.info("Frames: #{dump.frames.length}")

events = Queue.new
min_wait_time = 0.5

uploader = Thread.new do
  while x = events.pop
    to_upload = [x]
    events.size.times do
      to_upload.push(events.pop)
    end

    finish = to_upload.delete(:abort)
    $logger.info "UPLOAD: #{to_upload.size}"
    last_upload_time = Time.now

    http = Net::HTTP.new("localhost", 3000)

    request = Net::HTTP::Post.new("/api/upload/events")
    request["content-type"] = "application/json"
    request.body = {events: to_upload}.to_json
    response = http.request(request) # Use nokogiri, hpricot, etc to parse response.body.
    break if finish

    n = Time.now
    elapsed = n - last_upload_time
    last_upload_time = n

    sleep([elapsed - min_wait_time, 0].max)
  end
end

filename = "masks/dm/ball.json"
mask = Image.from_json(File.read(filename))
final_mask = Image.from_json(File.read("masks/dm/final_score.json"))
total_bonus_mask = Image.from_json(File.read("masks/dm/total_bonus.json"))
ball_save_mask = Image.from_json(File.read("masks/dm/ball_save.json"))

templates = (0..9).to_a.map do |n|
  [n, Image.from_json(File.read("masks/dm/#{n}.json"))]
end
separator = Image.from_json(File.read("masks/dm/separator.json"))

previous_total = nil
prof = false

class EventFrameAnnotater
  def initialize(logger, buffer, frame)
    @logger = logger
    @buffer = buffer
    @frame = frame
  end

  def push(event)
    event = event.merge(t: @frame.timestamp)
    @logger.info(event)
    @buffer.push(event)
  end
end

state = {}

module DigitMatcher
  class Score1P
    def initialize
      @templates = (0..9).to_a.map do |n|
        [n, Image.from_json(File.read("masks/dm/#{n}.json"))]
      end
      @separator = Image.from_json(File.read("masks/dm/separator.json"))
    end

    def detect(number)
      return ',' if @separator == number
      t = @templates.detect {|n, template|
        template == number
      }
      t[0] if t
    end
  end
end

module ScreenMatcher
  class Score
    def initialize(logger:, mask: "masks/dm/ball.json", digit_matcher: DigitMatcher::Score1P.new)
      @logger = logger
      @mask = Image.from_json(File.read(mask))
      @digit_matcher = digit_matcher
    end

    def analyze!(state, events, image)
      return unless image.matches_mask?(@mask)

      region_start = nil
      bounds = []

      (0...image.width).each do |x|
        empty = image.region_empty?(x, 0, 1, 23)
        if !region_start && !empty
          region_start = x
        elsif region_start && empty
          bounds << [region_start, x]
          region_start = nil
        end
      end

      digits = []
      success = true
      bounds.each do |bound|
        number = image.fit_to_masked_content(bound[0], 0, bound[1] - bound[0], 23)
        t = @digit_matcher.detect(number)

        unless t
          success = false
          break
        end

        digits.push t unless t == ','
      end

      if success && !digits.empty?
        total = 0
        digits.reverse.each.with_index.each do |d, i|
          total += d * (10 ** i)
        end
        if total != state[:previous_total]
          state[:previous_total] = total
          if total == 0
            if !state[:playing]
              state[:playing] = true
              state[:just_drained] = false
              state[:just_ball_saved] = false
              state[:game_id] = SecureRandom.uuid
              state[:current_player] = 1
              events.push(
                type: :game_start,
                player_number: state.fetch(:current_player),
                game_id: state.fetch(:game_id)
              )
              return true
            end
          else
            if !state[:playing]
              $logger.error "Unexpected score update while not playing"
            else
              state[:just_drained] = false
              state[:just_ball_saved] = false
              events.push(
                type: :update_score,
                score: total,
                player_number: state.fetch(:current_player),
                game_id: state.fetch(:game_id)
              )
              return true
            end
          end
        end
      end
      return false
    end
  end

  class Drain
    def initialize(logger:, mask: "masks/dm/total_bonus.json")
      @logger = logger
      @mask = Image.from_json(File.read(mask))
    end

    def analyze!(state, events, image)
      return unless image.matches_mask?(@mask)
      if state[:playing]
        if !state[:just_drained]
          state[:just_drained] = true
          events.push(
            type: :drain,
            player_number: state.fetch(:current_player),
            game_id: state.fetch(:game_id)
          )
        end
      else
        $logger.error "Unexpected total bonus while not playing"
      end
    end
  end

  class BallSave
    def initialize(logger:, mask: "masks/dm/ball_save.json")
      @logger = logger
      @mask = Image.from_json(File.read(mask))
    end

    def analyze!(state, events, image)
      return unless image.matches_mask?(@mask)

      if state[:playing]
        if !state[:just_ball_saved]
          state[:just_ball_saved] = true
          events.push(
            type: :ball_save,
            player_number: state.fetch(:current_player),
            game_id: state.fetch(:game_id)
          )
        end
      else
        $logger.error "Unexpected ball save while not playing"
      end
    end
  end

  class GameEnd
    def initialize(logger:, mask: "masks/dm/final_score.json")
      @logger = logger
      @mask = Image.from_json(File.read(mask))
    end

    def analyze!(state, events, image)
      return unless image.matches_mask?(@mask)

      if state[:playing]
        # TODO: Handle multiplayer games
        events.push(
          type: :game_end,
          player_number: state.fetch(:current_player),
          game_id: state.fetch(:game_id)
        )
        state = {}
      end
    end
  end
end

matchers = [
  ScreenMatcher::Score,
  ScreenMatcher::Drain,
  ScreenMatcher::BallSave,
  ScreenMatcher::GameEnd
].map {|x| x.new(logger: $logger) }

RubyProf.start if prof
times = []
dump.frames.each.with_index do |f, i|
  $logger.formatter = proc do |severity, datetime, progname, msg|
    date_format = datetime.strftime("%Y-%m-%d %H:%M:%S.%L")
    "#{severity} [#{date_format}] (#{i}): #{msg}\n"
  end
  start_time = Time.now
  image = f.monochrome_image
  annotater = EventFrameAnnotater.new($logger, events, f)

  matchers.detect do |m|
    m.analyze!(state, annotater, image)
  end
  finish_time = Time.now
  times.push(finish_time - start_time)
end

$logger.info("Average frame processing time: %ims" % (times.sum / times.length.to_f * 1000))
if prof
  result = RubyProf.stop
  printer = RubyProf::GraphHtmlPrinter.new(result)
  File.open("graph.html", "w") {|f| printer.print(f) }

  printer = RubyProf::CallStackPrinter.new(result)
  File.open("calls.html", "w") {|f| printer.print(f) }
end
events.push(:abort)
uploader.join
